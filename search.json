[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cookbook Polars for R",
    "section": "",
    "text": "Preface\nWelcome to the Polars cookbook for R users. The goal of the cookbook is to provide solutions to common tasks and problems in using Polars with R. It allows R users using their usual packages to quickly get the syntax required to use Polars with R.\nIt is structured around side-by-side comparisons between polars, dplyr and data.table.\nThis book is not a substitute for the official documentation of the rpolars project which is the definitive reference on the subject. It is simply intended to illustrate my use of Polars with R and can be a complementary to the official Polars documentation."
  },
  {
    "objectID": "index.html#what-is-polars",
    "href": "index.html#what-is-polars",
    "title": "Cookbook Polars for R",
    "section": "What is Polars ?",
    "text": "What is Polars ?\nPolars is a very fast and elegant dataframe library that does the same sort of thing as the main data manipulation packages in R including dplyr and data.table.\nMost of this book is structured examples of Polars, dplyr and data.table idiomatic code, with comments on the API and performance of the three."
  },
  {
    "objectID": "index.html#who-is-this-for",
    "href": "index.html#who-is-this-for",
    "title": "Cookbook Polars for R",
    "section": "Who is this for?",
    "text": "Who is this for?\nThis is not a beginner’s introduction to data programming, though you certainly don’t need to be an expert to read it. If you have some familiarity with any dataframe library, most of the examples should make sense, but if you’re familiar with dplyr or data.table they’ll make even more sense because all the Polars code is accompanied by the equivalent code.\nFor users of Python and in particular Pandas, you can consult this excellent book which was the inspiration for the one you are reading now."
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "Cookbook Polars for R",
    "section": "Contributing",
    "text": "Contributing\nThis book is free and open source, so please do open an issue if you notice a problem!"
  },
  {
    "objectID": "first_steps.html#installation",
    "href": "first_steps.html#installation",
    "title": "1  First steps with Polars and R",
    "section": "1.1 Installation",
    "text": "1.1 Installation\nUntil the R polars package is uploaded to CRAN, the polars package development team offers several solutions for installation.\nThe most practical one in my opinion at the moment is to use R-universe and install like this:\n\n# Install packages not yet installed\npackages &lt;- c(\"polars\")\ninstalled_packages &lt;- packages %in% rownames(installed.packages())\nif (any(installed_packages == FALSE)) {\n  install.packages(packages[!installed_packages], repos = \"https://rpolars.r-universe.dev\")\n}\nlibrary(polars)"
  },
  {
    "objectID": "first_steps.html#first-glimpse",
    "href": "first_steps.html#first-glimpse",
    "title": "1  First steps with Polars and R",
    "section": "1.2 First glimpse",
    "text": "1.2 First glimpse\nPolars’ main functions are stored in the “pl” namespace and can be accessed using the “pl$” prefix to prevent conflicts with other packages and base R function names. For more, see here.\nFirst example to convert the most famous R data frame (iris) to a Polars DataFrame:\n\niris_polars &lt;- pl$DataFrame(iris)\niris_polars\n\nshape: (150, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬───────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species   │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---       │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat       │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═══════════╡\n│ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa    │\n│ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa    │\n│ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa    │\n│ 4.6          ┆ 3.1         ┆ 1.5          ┆ 0.2         ┆ setosa    │\n│ …            ┆ …           ┆ …            ┆ …           ┆ …         │\n│ 6.3          ┆ 2.5         ┆ 5.0          ┆ 1.9         ┆ virginica │\n│ 6.5          ┆ 3.0         ┆ 5.2          ┆ 2.0         ┆ virginica │\n│ 6.2          ┆ 3.4         ┆ 5.4          ┆ 2.3         ┆ virginica │\n│ 5.9          ┆ 3.0         ┆ 5.1          ┆ 1.8         ┆ virginica │\n└──────────────┴─────────────┴──────────────┴─────────────┴───────────┘\n\n\nFor example, to count the number of lines of the iris data frame :\n\npolarsR base\n\n\n\n# With pl$ prefix\npl$DataFrame(iris)$height\n\n[1] 150\n\n# Using iris_polars\niris_polars$height\n\n[1] 150\n\n\n\n\n\nnrow(iris)\n\n[1] 150\n\n\n\n\n\nTo select the first 5 iris rows and the Petal.Length and Species columns, syntax is identical between Polars and R base:\n\npolarsR basedplyrdata.table\n\n\n\niris_polars[1:5, c(\"Petal.Length\", \"Species\")]\n\nshape: (5, 2)\n┌──────────────┬─────────┐\n│ Petal.Length ┆ Species │\n│ ---          ┆ ---     │\n│ f64          ┆ cat     │\n╞══════════════╪═════════╡\n│ 1.4          ┆ setosa  │\n│ 1.4          ┆ setosa  │\n│ 1.3          ┆ setosa  │\n│ 1.5          ┆ setosa  │\n│ 1.4          ┆ setosa  │\n└──────────────┴─────────┘\n\n\n\n\n\niris[1:5, c(\"Petal.Length\", \"Species\")]\n\n  Petal.Length Species\n1          1.4  setosa\n2          1.4  setosa\n3          1.3  setosa\n4          1.5  setosa\n5          1.4  setosa\n\n\n\n\n\niris |&gt; \n  slice(1:5) |&gt; \n  select(Petal.Length,Species)\n\n  Petal.Length Species\n1          1.4  setosa\n2          1.4  setosa\n3          1.3  setosa\n4          1.5  setosa\n5          1.4  setosa\n\n\n\n\n\niris_dt[1:5, .(Petal.Length, Species)]\n\n   Petal.Length Species\n1:          1.4  setosa\n2:          1.4  setosa\n3:          1.3  setosa\n4:          1.5  setosa\n5:          1.4  setosa"
  },
  {
    "objectID": "first_steps.html#data-structures",
    "href": "first_steps.html#data-structures",
    "title": "1  First steps with Polars and R",
    "section": "1.3 Data Structures",
    "text": "1.3 Data Structures\n\nThe core base data structures provided by Polars are Series and DataFrames.\n\n\n1.3.1 Series and vectors\n\n\n\n\n\n\nImportant\n\n\n\nSeries are a 1-dimensional data structure. Within a series all elements have the same Data Type.\n\n\nIn Polars objects, Series object are like R vectors.\nTo create a Polars Series from scratch:\n\npolarsR base\n\n\n\nmynumbers_serie &lt;- pl$Series(1:3)\nmyletters_serie &lt;- pl$Series(c(\"a\",\"b\",\"c\"))\n\n\n\n\nmynumbers_vector &lt;- 1:3\nmyletters_vector &lt;- c(\"a\",\"b\",\"c\")\n\n\n\n\n\n\n1.3.2 DataFrame and data.frame\n\n\n\n\n\n\nNote\n\n\n\nA DataFrame is a 2-dimensional data structure that is backed by a Series, and it can be seen as an abstraction of a collection (e.g. list) of Series.\n\n\nIn polars objects, DataFrame object are like R data.frame and close to a tibble and a data.table object.\nTo create a Polars DataFrame from scratch:\n\npolarsR basedplyrdata.table\n\n\n\n# Creation of a DataFrame object with Series\nmydf &lt;- pl$DataFrame(\n  col1 = mynumbers_serie,\n  col2 = myletters_serie\n)\n# Creation of a DataFrame object with Series and vectors\npl$DataFrame(\n  col1 = mynumbers_serie,\n  col2 = myletters_vector\n)\n\nshape: (3, 2)\n┌──────┬──────┐\n│ col1 ┆ col2 │\n│ ---  ┆ ---  │\n│ i32  ┆ str  │\n╞══════╪══════╡\n│ 1    ┆ a    │\n│ 2    ┆ b    │\n│ 3    ┆ c    │\n└──────┴──────┘\n\n\n\n\n\ndata.frame(\n  col1 = mynumbers_vector,\n  col2 = myletters_vector\n)\n\n  col1 col2\n1    1    a\n2    2    b\n3    3    c\n\n\n\n\n\ntibble(\n  col1 = mynumbers_vector,\n  col2 = myletters_vector\n)\n\n# A tibble: 3 × 2\n   col1 col2 \n  &lt;int&gt; &lt;chr&gt;\n1     1 a    \n2     2 b    \n3     3 c    \n\n\n\n\n\ndata.table(\n  col1 = mynumbers_vector,\n  col2 = myletters_vector\n)\n\n   col1 col2\n1:    1    a\n2:    2    b\n3:    3    c"
  },
  {
    "objectID": "first_steps.html#manipulation-of-series-and-dataframes-with-r-standard-functions",
    "href": "first_steps.html#manipulation-of-series-and-dataframes-with-r-standard-functions",
    "title": "1  First steps with Polars and R",
    "section": "1.4 Manipulation of Series and DataFrames with R standard functions",
    "text": "1.4 Manipulation of Series and DataFrames with R standard functions\nSeries and DataFrames can be manipulated with a lot of standard R functions.\nSome examples with Series:\n\nsum(mynumbers_serie)\n\n[1] 6\n\npaste(myletters_serie,collapse = \"\")\n\n[1] \"abc\"\n\n\nSome examples with DataFrames:\n\nnames(mydf)\n\n[1] \"col1\" \"col2\"\n\nncol(mydf)\n\n[1] 2"
  },
  {
    "objectID": "first_steps.html#expressions",
    "href": "first_steps.html#expressions",
    "title": "1  First steps with Polars and R",
    "section": "1.5 Expressions",
    "text": "1.5 Expressions\nHere I’m quoting what Damian Skrzypiec said in his blog about Polars expressions:\n\nOne of fundamental building blocks in Polars are Polars expressions. In general Polars expression is any function that transforms Polars series into another Polars series. There are few advantageous aspects of Polars expressions. Firstly expressions are optimized. Particularly if expression need to be executed on multiple columns, then it will be parallelized. It’s one of reasons behind Polars high performance. Another aspect is the fact the Polars implements an extensive set of builtin expressions that user can compose (chain) into more complex expressions.\n\nThis is what an Polars expression looks like:\n\npl$col(\"Petal.Length\")$round(decimals = 0)$alias(\"Petal.Length.rounded\")\n\nWhich means that: - Select column “Petal.Length” - Then round the column with 0 decimals - Then rename the column “Petal.Length.rounded”\n\n\n\n\n\n\nTip\n\n\n\nEvery expression produces a new expression, and that they can be piped together.\n\n\nFor example:\n\npl$col(\"bar\")$filter(pl.col(\"foo\") == 1)$sum()\n\nTo learn more about Polars expressions, see the official documentation.\n\nIf you have read this far and managed to reproduce the examples, congratulations! You are ready to dive into the deep end of Polars with R in the next parts of this cookbook! 🚀"
  },
  {
    "objectID": "data_manipulation.html#introduction-to-methods",
    "href": "data_manipulation.html#introduction-to-methods",
    "title": "2  Data manipulation",
    "section": "2.1 Introduction to methods",
    "text": "2.1 Introduction to methods\nThe added value of Polars consists in the methods. Those powerful methods are accessed using the $ operator.\n\nFor Series, see this section for the methods available in {polars}.\nFor DataFrames, see this section for the methods available in {polars}.\n\nSome examples with Series:\n\n# To get a sum\nmynumbers_serie$sum()\n\n[1] 6\n\n# To sort in descending order\nmynumbers_serie$sort(reverse = TRUE)\n\npolars Series: shape: (3,)\nSeries: 'col1' [i32]\n[\n    3\n    2\n    1\n]\n\n\nSome examples with DataFrame:\n\n# To get a character vector of column names\nmydf$columns\n\n[1] \"col1\" \"col2\"\n\n# To get dimensions of DataFrame\nmydf$shape\n\n[1] 3 2\n\n# We can mix standard R functions and methods\nlength(mydf$columns)\n\n[1] 2\n\n\nPolars includes a very useful chaining method in data manipulation operations. From this point of view, Polars is more like dplyr and data.table. This is how the chaining method is defined in the official documentation:\n\nIn polars our method chaining syntax takes the form object$m1()$m2(), where object is our data object, and m1() and m2() are appropriate methods, like subsetting or aggregation expressions.\n\nLet’s see an example with the iris dataset:\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$\n  groupby(\n  \"Species\")$\n  median()  \n\nshape: (3, 5)\n┌────────────┬──────────────┬─────────────┬──────────────┬─────────────┐\n│ Species    ┆ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width │\n│ ---        ┆ ---          ┆ ---         ┆ ---          ┆ ---         │\n│ cat        ┆ f64          ┆ f64         ┆ f64          ┆ f64         │\n╞════════════╪══════════════╪═════════════╪══════════════╪═════════════╡\n│ setosa     ┆ 5.0          ┆ 3.4         ┆ 1.5          ┆ 0.2         │\n│ versicolor ┆ 5.9          ┆ 2.8         ┆ 4.35         ┆ 1.3         │\n│ virginica  ┆ 6.5          ┆ 3.0         ┆ 5.55         ┆ 2.0         │\n└────────────┴──────────────┴─────────────┴──────────────┴─────────────┘\n\n\n\n\n\naggregate(. ~ Species, iris, median)\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa          5.0         3.4         1.50         0.2\n2 versicolor          5.9         2.8         4.35         1.3\n3  virginica          6.5         3.0         5.55         2.0\n\n\n\n\n\niris |&gt;\n  group_by(Species) |&gt;\n  summarise(across(everything(),median))\n\n# A tibble: 3 × 5\n  Species    Sepal.Length Sepal.Width Petal.Length Petal.Width\n  &lt;fct&gt;             &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n1 setosa              5           3.4         1.5          0.2\n2 versicolor          5.9         2.8         4.35         1.3\n3 virginica           6.5         3           5.55         2  \n\n\n\n\n\niris_dt[, lapply(.SD, median), by = Species]\n\n      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1:     setosa          5.0         3.4         1.50         0.2\n2: versicolor          5.9         2.8         4.35         1.3\n3:  virginica          6.5         3.0         5.55         2.0\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn the Polars code used above, you will notice that we have introduced line breaks. We could have written the whole code on the same line but for the sake of readability I prefer to separate the methods used by line breaks."
  },
  {
    "objectID": "data_manipulation.html#conversion-between-seriesdataframes-and-vectordata.frames",
    "href": "data_manipulation.html#conversion-between-seriesdataframes-and-vectordata.frames",
    "title": "2  Data manipulation",
    "section": "2.2 Conversion between Series/DataFrames and vector/data.frames",
    "text": "2.2 Conversion between Series/DataFrames and vector/data.frames\n\n2.2.1 From vector/data.frames to Series/DataFrames\nThese conversions have already been seen earlier in this book.\n\n# To convert vector to Polars Series\nmyvector &lt;- pl$Series(c(\"a\",\"b\",\"c\"))\n# To convert data.frames to DataFrames\niris_polars &lt;- pl$DataFrame(iris)\n\n\n\n2.2.2 From Series/DataFrames to vector/data.frames\nHere, we can use to_r() and to_data_frame() methods.\n\n# To convert Polars Series to vector or list\nmyletters_serie$to_r()\n\n[1] \"a\" \"b\" \"c\"\n\n# To convert DataFrames to data.frames\nmydf$to_data_frame()\n\n  col1 col2\n1    1    a\n2    2    b\n3    3    c"
  },
  {
    "objectID": "data_manipulation.html#some-initial-informations-on-a-dataframe",
    "href": "data_manipulation.html#some-initial-informations-on-a-dataframe",
    "title": "2  Data manipulation",
    "section": "2.3 Some initial informations on a DataFrame",
    "text": "2.3 Some initial informations on a DataFrame\n\n2.3.1 First overview of a DataFrame\nHere is a list of instructions that I frequently use to quickly get information about a DataFrame.\n\n# To get the schema (= a named list)\nmydf$schema\n\n$col1\nDataType: Int32\n\n$col2\nDataType: Utf8\n\n# To get column types as strings. \nmydf$dtype_strings()\n\n[1] \"i32\" \"str\"\n\n# To get an estimation of the total allocated size (in Bytes)\nmydf$estimated_size()\n\n[1] 47\n\n# To get the first n rows\nmydf$head(2)\n\nshape: (2, 2)\n┌──────┬──────┐\n│ col1 ┆ col2 │\n│ ---  ┆ ---  │\n│ i32  ┆ str  │\n╞══════╪══════╡\n│ 1    ┆ a    │\n│ 2    ┆ b    │\n└──────┴──────┘\n\n# To get the dimensions\nmydf$shape\n\n[1] 3 2\n\n\n\n\n\n\n\n\nCaution\n\n\n\nPolars API contains useful methods for quickly describing a DataFrame - describe and glimpse that has not yet been implemented (end of May 2023).\n\n\n\n2.3.1.1 Missing values\nAs in arrow, missing data is represented in Polars with a null value. This null missing value applies for all data types including numerical values.\nYou can manually define a missing value using NA value in R:\n\npl$DataFrame(\n  col1 = pl$Series(c(NA,\"b\",\"c\"))\n)\n\nshape: (3, 1)\n┌──────┐\n│ col1 │\n│ ---  │\n│ str  │\n╞══════╡\n│ null │\n│ b    │\n│ c    │\n└──────┘\n\n\n\n\n\n2.3.2 Count NA over columns in a DataFrame\nThe null_count() method can be used to count NA values of a DataFrame.\n\npolarsR basedplyrdata.table\n\n\n\nmydfNA &lt;- pl$DataFrame(\n  colA = pl$Series(c(\"a\",NA,\"c\")),\n  colB = pl$Series(c(\"d\",NA,NA)))\nmydfNA$null_count()\n\nshape: (1, 2)\n┌──────┬──────┐\n│ colA ┆ colB │\n│ ---  ┆ ---  │\n│ u32  ┆ u32  │\n╞══════╪══════╡\n│ 1    ┆ 2    │\n└──────┴──────┘\n\n\n\n\n\nmydfNA &lt;- data.frame(\n  colA = c(\"a\",NA,\"c\"),\n  colB = c(\"d\",NA,NA))\nsapply(mydfNA, function(x) sum(is.na(x)))\n\ncolA colB \n   1    2 \n\n\n\n\n\nmydfNA %&gt;%\n  summarise(across(everything(), ~sum(is.na(.))))\n\n  colA colB\n1    1    2\n\n\n\n\n\nmydfNA_dt &lt;- as.data.table(mydfNA)\nmydfNA_dt[, lapply(.SD, function(x) sum(is.na(x))), .SDcols = names(mydfNA_dt)]\n\n   colA colB\n1:    1    2"
  },
  {
    "objectID": "data_manipulation.html#filter-rows",
    "href": "data_manipulation.html#filter-rows",
    "title": "2  Data manipulation",
    "section": "2.4 Filter rows",
    "text": "2.4 Filter rows\nThe filter() method is used to filter the rows of a DataFrame. It must be used with the col() method which allows to designate the columns on which the filter condition will be applied.\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$filter(\n  pl$col(\"Petal.Length\") &gt; 6 & pl$col(\"Petal.Width\") &lt; 2)\n\nshape: (2, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬───────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species   │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---       │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat       │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═══════════╡\n│ 7.3          ┆ 2.9         ┆ 6.3          ┆ 1.8         ┆ virginica │\n│ 7.4          ┆ 2.8         ┆ 6.1          ┆ 1.9         ┆ virginica │\n└──────────────┴─────────────┴──────────────┴─────────────┴───────────┘\n\n\n\n\n\niris[iris$Petal.Length &gt; 6 & iris$Petal.Width &lt; 2,] # here don't forget the comma\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n108          7.3         2.9          6.3         1.8 virginica\n131          7.4         2.8          6.1         1.9 virginica\n\n\n\n\n\niris |&gt;\n  filter(Petal.Length &gt; 6 & Petal.Width &lt; 2) \n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          7.3         2.9          6.3         1.8 virginica\n2          7.4         2.8          6.1         1.9 virginica\n\n\n\n\n\niris_dt[Petal.Length &gt; 6 & Petal.Width &lt; 2]\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1:          7.3         2.9          6.3         1.8 virginica\n2:          7.4         2.8          6.1         1.9 virginica"
  },
  {
    "objectID": "data_manipulation.html#select",
    "href": "data_manipulation.html#select",
    "title": "2  Data manipulation",
    "section": "2.5 Select",
    "text": "2.5 Select\nThe select() method is used to select columns of a DataFrame. It must be used with the col() method which allows to designate the columns to be selected.\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$select(\n  pl$col(c(\"Petal.Length\",\"Petal.Width\"))\n)$head(3) # display the first 3 lines\n\nshape: (3, 2)\n┌──────────────┬─────────────┐\n│ Petal.Length ┆ Petal.Width │\n│ ---          ┆ ---         │\n│ f64          ┆ f64         │\n╞══════════════╪═════════════╡\n│ 1.4          ┆ 0.2         │\n│ 1.4          ┆ 0.2         │\n│ 1.3          ┆ 0.2         │\n└──────────────┴─────────────┘\n\n\n\n\n\niris[1:3,c(\"Petal.Length\",\"Petal.Width\")] \n\n  Petal.Length Petal.Width\n1          1.4         0.2\n2          1.4         0.2\n3          1.3         0.2\n\n\n\n\n\niris |&gt;\n  select(Petal.Length,Petal.Width) |&gt;\n  head(3)\n\n  Petal.Length Petal.Width\n1          1.4         0.2\n2          1.4         0.2\n3          1.3         0.2\n\n\n\n\n\niris_dt[1:3,.(Petal.Length,Petal.Width)]\n\n   Petal.Length Petal.Width\n1:          1.4         0.2\n2:          1.4         0.2\n3:          1.3         0.2\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWith Polars if you want to obtain a result in an R data.frame, you can simply add the method to_data_frame() at the end of the method chaining.\n\n\nSimilar to the dplyr package, the select() method can also be used to modify existing data. However, the result will exclude any columns that were not specified in the expression.\nFor example, if we want to get in the data.frame iris the Petal.Length column rounded without decimals.\n\npl$DataFrame(iris)$select(\n  pl$col(\"Petal.Length\")$round(decimals = 0)\n)$head(3) # display the first 3 lines\n\nshape: (3, 1)\n┌──────────────┐\n│ Petal.Length │\n│ ---          │\n│ f64          │\n╞══════════════╡\n│ 1.0          │\n│ 1.0          │\n│ 1.0          │\n└──────────────┘\n\n\nThe problem here is that we would like to keep all the iris columns and not just Petal.Length.\nAgain, let’s look at the official documentation:\n\nTo modify or add some columns—whilst preserving all others in the dataset—it is therefore better to use the with_columns() method.\n\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$with_columns(\n  pl$col(\"Petal.Length\")$round(decimals = 0)\n)$head(3) # display the first 3 lines\n\nshape: (3, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬─────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---     │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat     │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═════════╡\n│ 5.1          ┆ 3.5         ┆ 1.0          ┆ 0.2         ┆ setosa  │\n│ 4.9          ┆ 3.0         ┆ 1.0          ┆ 0.2         ┆ setosa  │\n│ 4.7          ┆ 3.2         ┆ 1.0          ┆ 0.2         ┆ setosa  │\n└──────────────┴─────────────┴──────────────┴─────────────┴─────────┘\n\n\n\n\n\niris$Petal.Length &lt;- round(iris$Petal.Length, digits = 0)\niris[1:3,]\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5            1         0.2  setosa\n2          4.9         3.0            1         0.2  setosa\n3          4.7         3.2            1         0.2  setosa\n\n\n\n\n\ndata(iris)\niris |&gt;\n  mutate(Petal.Length = round(Petal.Length,0)) |&gt;\n  head(3)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5            1         0.2  setosa\n2          4.9         3.0            1         0.2  setosa\n3          4.7         3.2            1         0.2  setosa\n\n\n\n\n\niris_dt[,Petal.Length := round(Petal.Length, digits = 0)]\niris_dt[1:3,]\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1:          5.1         3.5            1         0.2  setosa\n2:          4.9         3.0            1         0.2  setosa\n3:          4.7         3.2            1         0.2  setosa\n\n\n\n\n\nIf you want to add a column to a data.frame, you use the same syntax as above with with_columns(). Simply use the alias() method to specify the name of the newly created column.\n\npl$DataFrame(iris)$with_columns(\n  pl$col(\"Petal.Length\")$round(decimals = 0)$alias(\"Petal.Length.rounded\")\n)$head(3) # display the first 3 lines\n\nshape: (3, 6)\n┌──────────────┬─────────────┬──────────────┬─────────────┬─────────┬──────────────────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species ┆ Petal.Length.rounded │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---     ┆ ---                  │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat     ┆ f64                  │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═════════╪══════════════════════╡\n│ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa  ┆ 1.0                  │\n│ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa  ┆ 1.0                  │\n│ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa  ┆ 1.0                  │\n└──────────────┴─────────────┴──────────────┴─────────────┴─────────┴──────────────────────┘"
  },
  {
    "objectID": "data_manipulation.html#methods-agg-and-group_by",
    "href": "data_manipulation.html#methods-agg-and-group_by",
    "title": "2  Data manipulation",
    "section": "2.6 Methods agg and group_by",
    "text": "2.6 Methods agg and group_by\nAnother frequently used data manipulation is the aggregation of data by group. To do this, we indicate in the group_by() method which column will be used to group the data.frame. And the agg() method which specifies the expression to aggregate.\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$groupby(\n  \"Species\"\n)$agg(\n  pl$col(c(\"Petal.Length\",\"Petal.Width\"))$sum()\n)\n\nshape: (3, 3)\n┌────────────┬──────────────┬─────────────┐\n│ Species    ┆ Petal.Length ┆ Petal.Width │\n│ ---        ┆ ---          ┆ ---         │\n│ cat        ┆ f64          ┆ f64         │\n╞════════════╪══════════════╪═════════════╡\n│ setosa     ┆ 73.1         ┆ 12.3        │\n│ versicolor ┆ 213.0        ┆ 66.3        │\n│ virginica  ┆ 277.6        ┆ 101.3       │\n└────────────┴──────────────┴─────────────┘\n\n\n\n\n\naggregate(cbind(Petal.Length, Petal.Width) ~ Species, data = iris, FUN = sum)\n\n     Species Petal.Length Petal.Width\n1     setosa         73.1        12.3\n2 versicolor        213.0        66.3\n3  virginica        277.6       101.3\n\n\n\n\n\ndata(iris)\niris |&gt;\n  group_by(Species) |&gt;\n  summarise(across(c(Petal.Length, Petal.Width), sum)) \n\n# A tibble: 3 × 3\n  Species    Petal.Length Petal.Width\n  &lt;fct&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 setosa             73.1        12.3\n2 versicolor        213          66.3\n3 virginica         278.        101. \n\n\n\n\n\niris_dt &lt;- as.data.table(iris)\niris_dt[, .(Petal.Length = sum(Petal.Length), Petal.Width = sum(Petal.Width)), by = Species]\n\n      Species Petal.Length Petal.Width\n1:     setosa         73.1        12.3\n2: versicolor        213.0        66.3\n3:  virginica        277.6       101.3"
  },
  {
    "objectID": "data_manipulation.html#join-dataframes",
    "href": "data_manipulation.html#join-dataframes",
    "title": "2  Data manipulation",
    "section": "2.7 Join DataFrames",
    "text": "2.7 Join DataFrames\nTo perform joins, the join() method must be used.\n\npolarsR basedplyrdata.table\n\n\n\n# First, creation of colors_species Polars DataFrame\ncolors &lt;- pl$DataFrame(\n  Surname = pl$Series(c(\"toto\",\"titi\",\"tata\")),\n  Color = pl$Series(c(\"blue\",\"red\",\"yellow\"))\n)\nvalues &lt;- pl$DataFrame(\n  Surname = pl$Series(c(\"toto\",\"titi\",\"tata\")),\n  value = pl$Series(c(10,20,30))\n)\n# Let's join !\ncolors$join(\n  other = values,\n  on = \"Surname\",\n  how = \"left\"\n)\n\nshape: (3, 3)\n┌─────────┬────────┬───────┐\n│ Surname ┆ Color  ┆ value │\n│ ---     ┆ ---    ┆ ---   │\n│ str     ┆ str    ┆ f64   │\n╞═════════╪════════╪═══════╡\n│ toto    ┆ blue   ┆ 10.0  │\n│ titi    ┆ red    ┆ 20.0  │\n│ tata    ┆ yellow ┆ 30.0  │\n└─────────┴────────┴───────┘\n\n\n\n\n\ncolors &lt;- data.frame(\n  Surname = c(\"toto\",\"titi\",\"tata\"),\n  Color = c(\"blue\",\"red\",\"yellow\")\n)\nvalues &lt;- data.frame(\n  Surname = c(\"toto\",\"titi\",\"tata\"),\n  value = c(10,20,30)\n)\nmerge(colors, values, by = \"Surname\", all.x = TRUE)\n\n  Surname  Color value\n1    tata yellow    30\n2    titi    red    20\n3    toto   blue    10\n\n\n\n\n\ncolors |&gt;\n  left_join(values,\n            by = \"Surname\") \n\n  Surname  Color value\n1    toto   blue    10\n2    titi    red    20\n3    tata yellow    30\n\n\n\n\n\nmerge(as.data.table(colors), \n      as.data.table(values), \n      by = \"Surname\", all.x = TRUE)\n\n   Surname  Color value\n1:    tata yellow    30\n2:    titi    red    20\n3:    toto   blue    10"
  },
  {
    "objectID": "data_manipulation.html#others-useful-methods",
    "href": "data_manipulation.html#others-useful-methods",
    "title": "2  Data manipulation",
    "section": "2.8 Others useful methods",
    "text": "2.8 Others useful methods\n\n2.8.1 On Series\n\n2.8.1.1 Change name of Series\nThe alias() method is very useful especially in method chaining operation.\nWith R base, the syntax is longer.\n\npolarsR base\n\n\n\npl$Series(1:3, name = \"toto\")$alias(\"titi\")\n\npolars Series: shape: (3,)\nSeries: 'titi' [i32]\n[\n    1\n    2\n    3\n]\n\n\n\n\n\ntoto &lt;- 1:3\ntiti &lt;- toto\nrm(toto)\n\n\n\n\n\n\n2.8.1.2 Reduce Boolean Series\nThe all() and any() methods can be used to check if all or any values in a vector evaluate to TRUE for some expression.\n\npolarsR base\n\n\n\n# all(pl$Series(c(TRUE,TRUE))) doesn't work\npl$Series(c(TRUE, TRUE, NA))$all()\n\n[1] FALSE\n\npl$Series(c(TRUE, TRUE, FALSE))$all()\n\n[1] FALSE\n\npl$Series(c(TRUE, TRUE, TRUE))$all()\n\n[1] TRUE\n\n\n\n\n\nall(c(TRUE,TRUE,NA))\n\n[1] NA\n\nall(c(TRUE,TRUE,FALSE))\n\n[1] FALSE\n\nall(c(TRUE,TRUE,TRUE))\n\n[1] TRUE\n\n\n\n\n\n\n\n2.8.1.3 Get data type of Series\nThe dtype() method can be used to get data type of Series.\n\npolarsR base\n\n\n\npl$Series(letters)$dtype\n\nDataType: Utf8\n\npl$Series(c(1, 2))$dtype\n\nDataType: Float64\n\npl$DataFrame(iris)$select(\"Species\")$to_series()$dtype\n\nDataType: Categorical(\n    Some(\n        Local(\n            LargeUtf8Array[setosa, versicolor, virginica],\n        ),\n    ),\n)\n\n\n\n\n\ninfer_type(letters)\n\nUtf8\nstring\n\ninfer_type(c(1, 2))\n\nFloat64\ndouble\n\ninfer_type(iris$Species)\n\nDictionaryType\ndictionary&lt;values=string, indices=int8&gt;\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nPolars is strongly typed. print(ls(pl$dtypes)) returns the full list of valid Polars types. Caution, some type names differ from what they are called in R base. See below!\n\n\n\npolarsR base\n\n\n\npl$Series(c(\"x\",\"y\",\"z\"))$dtype\n\nDataType: Utf8\n\npl$Series(c(1, 2, 3))$dtype\n\nDataType: Float64\n\npl$Series(c(1:3))$dtype\n\nDataType: Int32\n\npl$Series(c(TRUE,FALSE))$dtype\n\nDataType: Boolean\n\npl$DataFrame(iris)$select(\"Species\")$to_series()$dtype\n\nDataType: Categorical(\n    Some(\n        Local(\n            LargeUtf8Array[setosa, versicolor, virginica],\n        ),\n    ),\n)\n\npl$Series(Sys.Date())$dtype\n\nDataType: Date\n\npl$Series(c(0,1))$dtype\n\nDataType: Float64\n\n\n\n\n\ntypeof(c(\"x\",\"y\",\"z\"))\n\n[1] \"character\"\n\ntypeof(c(1, 2, 3))\n\n[1] \"double\"\n\ntypeof(c(1:3))\n\n[1] \"integer\"\n\ntypeof(c(TRUE,FALSE))\n\n[1] \"logical\"\n\ntypeof(iris$Species)\n\n[1] \"integer\"\n\ntypeof(Sys.Date())\n\n[1] \"double\"\n\n\n\n\n\nTo summarise the main types between Polars and R:\n\n\n\nPolars\nR Base\n\n\n\n\nUtf8\ncharacter\n\n\nFloat64\ndouble\n\n\nInt32\ninteger\n\n\nBoolean\nlogical\n\n\nCategorical\nFactor\n\n\nDate\nDate\n\n\n\nTo learn more about Data types in Polars, see here.\n\n\n2.8.1.4 Cast\nThe cast() method can be used to convert the data types of a column to a new one.\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$with_columns(\n  pl$col(\"Petal.Length\")$cast(pl$Int8), # The \"Petal.Length\" column is converted into integers\n  pl$col(\"Species\")$cast(pl$Utf8) # The \"Species\" column is converted into strings\n  )$schema\n\n$Sepal.Length\nDataType: Float64\n\n$Sepal.Width\nDataType: Float64\n\n$Petal.Length\nDataType: Int8\n\n$Petal.Width\nDataType: Float64\n\n$Species\nDataType: Utf8\n\n\n\n\n\ndata(iris)\niris$Petal.Length &lt;- as.integer(iris$Petal.Length)\niris$Species &lt;- as.integer(iris$Species)\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: int  1 1 1 1 1 1 1 1 1 1 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : int  1 1 1 1 1 1 1 1 1 1 ...\n\n\n\n\n\ndata(iris)\niris |&gt;\n  mutate(\n    Petal.Length = as.integer(Petal.Length),\n    Species = as.character(Species)) |&gt;\n  str()\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: int  1 1 1 1 1 1 1 1 1 1 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n\n\n\n\n\niris_dt[, `:=`(Petal.Length = as.integer(Petal.Length),\n               Species = as.character(Species))]\nstr(iris_dt)\n\nClasses 'data.table' and 'data.frame':  150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: int  1 1 1 1 1 1 1 1 1 1 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen working with very large tables we can Reduce the memory footprint by modifying the number of bits allocated to an element. ⚠️\n\n\nFor example, the example below illustrates how converting Float64 to Float8 reduces memory usage:\n\npl$DataFrame(iris)$estimated_size()\n\n[1] 5457\n\n#| label: reduce-footprint-polars\npl$DataFrame(iris)$with_columns(\n  pl$col(\"Petal.Length\")$cast(pl$Float32), \n  pl$col(\"Petal.Width\")$cast(pl$Float32), \n  pl$col(\"Sepal.Length\")$cast(pl$Float32), \n  pl$col(\"Sepal.Width\")$cast(pl$Float32)\n  )$estimated_size()\n\n[1] 3057\n\n\nWhen performing downcasting, it is crucial to ensure that the chosen number of bits is sufficient to accommodate the largest and smallest numbers in the column.\nA quick reminder:\n\n\n\nType\nRange\nAccuracy\n\n\n\n\nInt8\n-128 to +127\n\n\n\nInt16\n-32768 to +32767\n\n\n\nInt32\n-2147483648 to +2147483647\n\n\n\nInt64\n–2E63 to –2E63-1\n\n\n\nFloat32\n-3.4E+38 to +3.4E+38\nabout 7 decimal digits\n\n\nFloat64\n-1.7E+308 to +1.7E+308\nabout 16 decimal digits\n\n\n\n\n\n2.8.1.5 Check if Series is numeric\nThe is_numeric() method can be used to check if Series is numeric.\nNote that unlike R base, there is no method to check if a Series is character (in this case, its type is anyway Utf8).\n\npolarsR base\n\n\n\npl$Series(1:4)$is_numeric()\n\n[1] TRUE\n\npl$Series(c(\"a\", \"b\", \"c\"))$is_numeric()\n\n[1] FALSE\n\n\n\n\n\nis.numeric(1:4)\n\n[1] TRUE\n\nis.numeric(c(\"a\",\"b\",\"c\"))\n\n[1] FALSE\n\n\n\n\n\n\n\n2.8.1.6 Check if Series is sorted\nThe is_sorted() method can be used to check if Series is sorted.\nNote that R base provides is.unsorted() which returns the opposite boolean to is_sorted() of Polars.\n\npolarsR base\n\n\n\npl$Series(1:4)$is_sorted()\n\n[1] TRUE\n\npl$Series(c(1,3,2))$is_sorted()\n\n[1] FALSE\n\n\n\n\n\nis.unsorted(1:4)\n\n[1] FALSE\n\nis.unsorted(c(1,3,2))\n\n[1] TRUE\n\n\n\n\n\n\n\n2.8.1.7 Get length of a Series\nThe len() method can be used to get the length of a Series.\n\npolarsR base\n\n\n\npl$Series(1:4)$len()\n\n[1] 4\n\n\n\n\n\nlength(1:4)\n\n[1] 4\n\n\n\n\n\n\n\n2.8.1.8 Check if Series are equal\nThe series_equal() method can be used to check if a Series is equal with another Series.\n\n\n\n\n\n\nTip\n\n\n\nCaution, if two series are identical but one is named and the other is not then series_equal() returns FALSE.\n\n\n\npolarsR base\n\n\n\npl$Series(1:4)$series_equal(pl$Series(1:4))\n\n[1] TRUE\n\npl$Series(1:4,name = \"toto\")$series_equal(pl$Series(1:4))\n\n[1] FALSE\n\n\n\n\n\nidentical(1:4,1:4)\n\n[1] TRUE\n\n\n\n\n\n\n\n2.8.1.9 Convert Series to Polars DataFrame\nThe to_frame() method can be used to convert a Series to a DataFrame.\nIn this case, a DataFrame with only one column will be created. If the Series is initially named then the column of the DataFrame will be named as such.\n\npl$Series(1:3, \"toto\")$to_frame()\n\nshape: (3, 1)\n┌──────┐\n│ toto │\n│ ---  │\n│ i32  │\n╞══════╡\n│ 1    │\n│ 2    │\n│ 3    │\n└──────┘\n\n\n\n\n2.8.1.10 Get value Counts of a Series\nThe value_counts() method can be used to get a value counts of a Series.\n\npolarsR basedplyrdata.table\n\n\n\npl$Series(iris$Species)$value_counts()\n\nshape: (3, 2)\n┌────────────┬────────┐\n│            ┆ counts │\n│ ---        ┆ ---    │\n│ cat        ┆ u32    │\n╞════════════╪════════╡\n│ setosa     ┆ 50     │\n│ versicolor ┆ 50     │\n│ virginica  ┆ 50     │\n└────────────┴────────┘\n\n\n\n\n\ntable(iris$Species)\n\n\n    setosa versicolor  virginica \n        50         50         50 \n\n\n\n\n\niris |&gt;\n  count(Species)\n\n     Species  n\n1     setosa 50\n2 versicolor 50\n3  virginica 50\n\n\n\n\n\niris_dt[, .N, by = Species]\n\n      Species  N\n1:     setosa 50\n2: versicolor 50\n3:  virginica 50\n\n\n\n\n\n\n\n2.8.1.11 Sum across Series\nThe sum() method can be used to get a sum of a Series.\n\nFrom a single Series:\n\n\npolarsR base\n\n\n\npl$Series(1:3)$sum()\n\n[1] 6\n\n\n\n\n\nsum(c(1:3))\n\n[1] 6\n\n\n\n\n\n\nFrom a DataFrame and a column as a string:\n\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$select(pl$sum(\"Petal.Length\"))\n\nshape: (1, 1)\n┌──────────────┐\n│ Petal.Length │\n│ ---          │\n│ f64          │\n╞══════════════╡\n│ 563.7        │\n└──────────────┘\n\n\n\n\n\nsum(iris$Petal.Length)\n\n[1] 563.7\n\n\n\n\n\niris %&gt;% summarise(sum(Petal.Length))\n\n  sum(Petal.Length)\n1             563.7\n\n\n\n\n\nsum(iris_dt[, Petal.Length])\n\n[1] 496\n\n\n\n\n\n\nFrom a DataFrame and a column as an expression:\n\n\npl$DataFrame(iris)$select(pl$sum(pl$col(\"Petal.Width\")))\n\nshape: (1, 1)\n┌─────────────┐\n│ Petal.Width │\n│ ---         │\n│ f64         │\n╞═════════════╡\n│ 179.9       │\n└─────────────┘\n\n\n\nFrom a DataFrame and a column as a list and sum horizontally:\n\nIn this case, use with_column() method.\n\npolarsR basedplyrdata.table\n\n\n\ndf_pl &lt;- pl$DataFrame(col1 = c(10L,20L), col2= c(30L,40L), col3 = c(40L,50L))\ndf_pl$with_column(pl$sum(list(\"col1\", \"col3\")))\n\nshape: (2, 4)\n┌──────┬──────┬──────┬─────┐\n│ col1 ┆ col2 ┆ col3 ┆ sum │\n│ ---  ┆ ---  ┆ ---  ┆ --- │\n│ i32  ┆ i32  ┆ i32  ┆ i32 │\n╞══════╪══════╪══════╪═════╡\n│ 10   ┆ 30   ┆ 40   ┆ 50  │\n│ 20   ┆ 40   ┆ 50   ┆ 70  │\n└──────┴──────┴──────┴─────┘\n\n\n\n\n\ndf &lt;- data.frame(col1 = c(10L,20L), col2= c(30L,40L), col3 = c(40L,50L))\nmysum &lt;- rowSums(df[, c(\"col1\", \"col3\")])\ncbind(df,mysum)\n\n  col1 col2 col3 mysum\n1   10   30   40    50\n2   20   40   50    70\n\n\n\n\n\ndf %&gt;%\n  rowwise() %&gt;% \n  mutate(mysum = sum(col1,col3))\n\n# A tibble: 2 × 4\n# Rowwise: \n   col1  col2  col3 mysum\n  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1    10    30    40    50\n2    20    40    50    70\n\n\n\n\n\ndf_dt &lt;- as.data.table(df)\ndf_dt[, somme := rowSums(.SD), .SDcols = c(\"col1\", \"col3\")]\nprint(df_dt)\n\n   col1 col2 col3 somme\n1:   10   30   40    50\n2:   20   40   50    70\n\n\n\n\n\n\nFrom a DataFrame and sum horizontally all columns:\n\nIn this case, use list(*).\n\ndf_pl$with_column(pl$sum(list(\"*\")))\n\nshape: (2, 4)\n┌──────┬──────┬──────┬─────┐\n│ col1 ┆ col2 ┆ col3 ┆ sum │\n│ ---  ┆ ---  ┆ ---  ┆ --- │\n│ i32  ┆ i32  ┆ i32  ┆ i32 │\n╞══════╪══════╪══════╪═════╡\n│ 10   ┆ 30   ┆ 40   ┆ 80  │\n│ 20   ┆ 40   ┆ 50   ┆ 110 │\n└──────┴──────┴──────┴─────┘\n\n\nWith iris Dataframe, you must first select numerical variables:\n\npl$DataFrame(iris)$\n  select(\n  pl$col(c(\"Petal.Length\",\"Petal.Width\")))$\n  with_column(pl$sum(list(\"*\")))\n\nshape: (150, 3)\n┌──────────────┬─────────────┬─────┐\n│ Petal.Length ┆ Petal.Width ┆ sum │\n│ ---          ┆ ---         ┆ --- │\n│ f64          ┆ f64         ┆ f64 │\n╞══════════════╪═════════════╪═════╡\n│ 1.4          ┆ 0.2         ┆ 1.6 │\n│ 1.4          ┆ 0.2         ┆ 1.6 │\n│ 1.3          ┆ 0.2         ┆ 1.5 │\n│ 1.5          ┆ 0.2         ┆ 1.7 │\n│ …            ┆ …           ┆ …   │\n│ 5.0          ┆ 1.9         ┆ 6.9 │\n│ 5.2          ┆ 2.0         ┆ 7.2 │\n│ 5.4          ┆ 2.3         ┆ 7.7 │\n│ 5.1          ┆ 1.8         ┆ 6.9 │\n└──────────────┴─────────────┴─────┘\n\n\n\n\n\n2.8.2 On DataFrames\n\n2.8.2.1 Get Series from DataFrame\nThe to_series() method can be used to get one column from DataFrame as Series.\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$select(pl$col(\"Petal.Length\"))$to_series()\n\npolars Series: shape: (150,)\nSeries: 'Petal.Length' [f64]\n[\n    1.4\n    1.4\n    1.3\n    1.5\n    1.4\n    1.7\n    1.4\n    1.5\n    1.4\n    1.5\n    1.5\n    1.6\n    …\n    5.5\n    4.8\n    5.4\n    5.6\n    5.1\n    5.1\n    5.9\n    5.7\n    5.2\n    5.0\n    5.2\n    5.4\n    5.1\n]\n\n\n\n\n\niris$Petal.Length\n\n  [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4\n [19] 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 1.6 1.5 1.5 1.4 1.5 1.2\n [37] 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0\n [55] 4.6 4.5 4.7 3.3 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0\n [73] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0\n [91] 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3\n[109] 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0\n[127] 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9\n[145] 5.7 5.2 5.0 5.2 5.4 5.1\n\n\n\n\n\niris |&gt;\n  pull(Petal.Length)\n\n  [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4\n [19] 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 1.6 1.5 1.5 1.4 1.5 1.2\n [37] 1.3 1.4 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0\n [55] 4.6 4.5 4.7 3.3 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0\n [73] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0\n [91] 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3\n[109] 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0\n[127] 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9\n[145] 5.7 5.2 5.0 5.2 5.4 5.1\n\n\n\n\n\niris_dt[, c(Petal.Length)]\n\n  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4 4 3 4 3 3 4 4 4 3 4 4 4 4 3 4 4 4 4\n [75] 4 4 4 5 4 3 3 3 3 5 4 4 4 4 4 4 4 4 4 3 4 4 4 4 3 4 6 5 5 5 5 6 4 6 5 6 5\n[112] 5 5 5 5 5 5 6 6 5 5 4 6 4 5 6 4 4 5 5 6 6 5 5 5 6 5 5 4 5 5 5 5 5 5 5 5 5\n[149] 5 5\n\n\n\n\n\n\n\n2.8.2.2 Get a slice of a DataFrame\nThe to_series() method can be used to get a slice of a DataFrame.\n\n\n\n\n\n\nImportant\n\n\n\nWith Polars, numeric default is 0! Thus the equivalent to slice(1,3) with Polars will be 2:4 in R Base and data.table and slice(1,4) with dplyr.\n\n\n\npolarsR basedplyrdata.table\n\n\n\npl$DataFrame(iris)$slice(1,3)\n\nshape: (3, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬─────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---     │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat     │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═════════╡\n│ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa  │\n│ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa  │\n│ 4.6          ┆ 3.1         ┆ 1.5          ┆ 0.2         ┆ setosa  │\n└──────────────┴─────────────┴──────────────┴─────────────┴─────────┘\n\n\n\n\n\niris[2:4,]\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n\n\n\n\n\niris |&gt;\n  slice(2:4)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          4.9         3.0          1.4         0.2  setosa\n2          4.7         3.2          1.3         0.2  setosa\n3          4.6         3.1          1.5         0.2  setosa\n\n\n\n\n\niris_dt[2:4,]\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1:          4.9         3.0            1         0.2  setosa\n2:          4.7         3.2            1         0.2  setosa\n3:          4.6         3.1            1         0.2  setosa\n\n\n\n\n\n\n\n2.8.2.3 Sort a DataFrame\nThe sort() method can be used to sort a DataFrame.\n\npolarsR basedplyrdata.table\n\n\n\n# Sort by one column\npl$DataFrame(iris\n  )$sort(\"Species\"\n  )$head(3)\n\nshape: (3, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬─────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---     │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat     │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═════════╡\n│ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa  │\n│ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa  │\n│ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa  │\n└──────────────┴─────────────┴──────────────┴─────────────┴─────────┘\n\n# Sort by two columns\npl$DataFrame(iris\n  )$sort(c(\"Species\",\"Petal.Length\")\n  )$head(3)\n\nshape: (3, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬─────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---     │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat     │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═════════╡\n│ 4.6          ┆ 3.6         ┆ 1.0          ┆ 0.2         ┆ setosa  │\n│ 4.3          ┆ 3.0         ┆ 1.1          ┆ 0.1         ┆ setosa  │\n│ 5.8          ┆ 4.0         ┆ 1.2          ┆ 0.2         ┆ setosa  │\n└──────────────┴─────────────┴──────────────┴─────────────┴─────────┘\n\n# Sort by two columns one in a decreasing manner and the other in an increasing manner\npl$DataFrame(iris\n  )$sort(c(\"Species\",\"Petal.Length\"), descending = c(TRUE,FALSE)\n  )$head(3)\n\nshape: (3, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬───────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species   │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---       │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ cat       │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═══════════╡\n│ 4.9          ┆ 2.5         ┆ 4.5          ┆ 1.7         ┆ virginica │\n│ 6.2          ┆ 2.8         ┆ 4.8          ┆ 1.8         ┆ virginica │\n│ 6.0          ┆ 3.0         ┆ 4.8          ┆ 1.8         ┆ virginica │\n└──────────────┴─────────────┴──────────────┴─────────────┴───────────┘\n\n\n\n\n\n# Sort by one column\niris[order(iris$Species),][1:3,]\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n\n# Sort by two columns\niris[order(iris$Species,iris$Petal.Length),][1:3,]\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n23          4.6         3.6          1.0         0.2  setosa\n14          4.3         3.0          1.1         0.1  setosa\n15          5.8         4.0          1.2         0.2  setosa\n\n# Sort by two columns one in a decreasing manner and the other in an increasing manner\niris[order(rev(iris$Species),iris$Petal.Length),][1:3,]\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n107          4.9         2.5          4.5         1.7 virginica\n127          6.2         2.8          4.8         1.8 virginica\n139          6.0         3.0          4.8         1.8 virginica\n\n\n\n\n\n# Sort by one column\niris |&gt;\n  arrange(Species) |&gt;\n  head(3)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n\n# Sort by two columns\niris |&gt;\n  arrange(Species, Petal.Length) |&gt;\n  head(3)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          4.6         3.6          1.0         0.2  setosa\n2          4.3         3.0          1.1         0.1  setosa\n3          5.8         4.0          1.2         0.2  setosa\n\n# Sort by two columns one in a decreasing manner and the other in an increasing manner\niris |&gt;\n  arrange(desc(Species), Petal.Length) |&gt;\n  head(3)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          4.9         2.5          4.5         1.7 virginica\n2          6.2         2.8          4.8         1.8 virginica\n3          6.0         3.0          4.8         1.8 virginica\n\n\n\n\n\n# Sort by one column\niris_dt[order(Species)][1:3,]\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1:          5.1         3.5            1         0.2  setosa\n2:          4.9         3.0            1         0.2  setosa\n3:          4.7         3.2            1         0.2  setosa\n\n# Sort by two columns\niris_dt[order(Species,Petal.Length)][1:3,]\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1:          5.1         3.5            1         0.2  setosa\n2:          4.9         3.0            1         0.2  setosa\n3:          4.7         3.2            1         0.2  setosa\n\n# Sort by two columns one in a decreasing manner and the other in an increasing manner\niris_dt[order(-Species,Petal.Length)][1:3,]\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1:          4.9         2.5            4         1.7 virginica\n2:          5.6         2.8            4         2.0 virginica\n3:          6.3         2.7            4         1.8 virginica\n\n\n\n\n\n\n\n2.8.2.4 Get a structure from a DataFrame\nThe to_struct() method can be used to get a structure from a DataFrame.\n\nmystruc &lt;- mydf$to_struct()\nmystruc\n\npolars Series: shape: (3,)\nSeries: '' [struct[2]]\n[\n    {1,\"a\"}\n    {2,\"b\"}\n    {3,\"c\"}\n]\n\n\nto_struct() returns a Series which can be converted to a R list with to_r method.\n\nmylist &lt;- mystruc$to_r()\nmylist\n\n$col1\n[1] 1 2 3\n\n$col2\n[1] \"a\" \"b\" \"c\"\n\nattr(,\"is_struct\")\n[1] TRUE\n\n\nmylist is now a list where each element is a column of the initial DataFrame.\nWith to_frame() and unnest() methods, we can reconstruct the original DataFrame:\n\nback_df &lt;- mystruc$to_frame()$unnest()\nback_df\n\nshape: (3, 2)\n┌──────┬──────┐\n│ col1 ┆ col2 │\n│ ---  ┆ ---  │\n│ i32  ┆ str  │\n╞══════╪══════╡\n│ 1    ┆ a    │\n│ 2    ┆ b    │\n│ 3    ┆ c    │\n└──────┴──────┘\n\n\n\n\n2.8.2.5 Drop all rows that contain null values\nThe drop_nulls() method can be used to drop all rows that contain null values in a DataFrame.\nBy default, drop_nulls() use all columns to drop rows:\n\npolarsR basedplyrdata.table\n\n\n\ndata_pl &lt;- pl$DataFrame(\n  col1 = pl$Series(c(NA,\"b\",\"c\")),\n  col2 = pl$Series(c(1,2,NA))\n)\ndata_pl$drop_nulls()\n\nshape: (1, 2)\n┌──────┬──────┐\n│ col1 ┆ col2 │\n│ ---  ┆ ---  │\n│ str  ┆ f64  │\n╞══════╪══════╡\n│ b    ┆ 2.0  │\n└──────┴──────┘\n\n\n\n\n\ndata_df &lt;- data.frame(\n  col1 = c(NA, \"b\", \"c\"),\n  col2 = c(1, 2, NA)\n)\ndata_df[complete.cases(data_df), ]\n\n  col1 col2\n2    b    2\n\n\n\n\n\ndata_df &lt;- data.frame(\n  col1 = c(NA, \"b\", \"c\"),\n  col2 = c(1, 2, NA)\n)\ndata_df %&gt;%\n  filter(complete.cases(.))\n\n  col1 col2\n1    b    2\n\n\n\n\n\ndata_dt &lt;- data.table(\n  col1 = c(NA, \"b\", \"c\"),\n  col2 = c(1, 2, NA)\n)\nna.omit(data_dt)\n\n   col1 col2\n1:    b    2\n\n\n\n\n\nIf you want, you can specify a column (or multiple columns):\n\npolarsR basedplyrdata.table\n\n\n\ndata_pl$drop_nulls(\"col1\")\n\nshape: (2, 2)\n┌──────┬──────┐\n│ col1 ┆ col2 │\n│ ---  ┆ ---  │\n│ str  ┆ f64  │\n╞══════╪══════╡\n│ b    ┆ 2.0  │\n│ c    ┆ null │\n└──────┴──────┘\n\n\n\n\n\ndata_df[!is.na(data_df$col1), ]\n\n  col1 col2\n2    b    2\n3    c   NA\n\n\n\n\n\ndata_df %&gt;%\n  filter(!is.na(col1))\n\n  col1 col2\n1    b    2\n2    c   NA\n\n\n\n\n\ndata_dt[complete.cases(data_dt[, .SD, .SDcols = \"col1\"]), ]\n\n   col1 col2\n1:    b    2\n2:    c   NA"
  },
  {
    "objectID": "data_manipulation.html#list-of-methods-to-apply-to-series",
    "href": "data_manipulation.html#list-of-methods-to-apply-to-series",
    "title": "2  Data manipulation",
    "section": "2.9 List of methods to apply to Series",
    "text": "2.9 List of methods to apply to Series\nTo learn more about the methods to be applied to the Series, see this page.\n\n# See all exported methods for Series\nls(polars:::Series)\n\n [1] \"abs\"           \"add\"           \"alias\"         \"all\"          \n [5] \"any\"           \"append\"        \"apply\"         \"arg_max\"      \n [9] \"arg_min\"       \"arr\"           \"ceil\"          \"chunk_lengths\"\n[13] \"clone\"         \"compare\"       \"cumsum\"        \"div\"          \n[17] \"dtype\"         \"expr\"          \"flags\"         \"floor\"        \n[21] \"is_numeric\"    \"is_sorted\"     \"len\"           \"max\"          \n[25] \"mean\"          \"median\"        \"min\"           \"mul\"          \n[29] \"name\"          \"print\"         \"rem\"           \"rename\"       \n[33] \"rep\"           \"series_equal\"  \"set_sorted\"    \"shape\"        \n[37] \"sort\"          \"std\"           \"sub\"           \"sum\"          \n[41] \"to_frame\"      \"to_lit\"        \"to_r\"          \"to_r_list\"    \n[45] \"to_r_vector\"   \"to_vector\"     \"value_counts\"  \"var\"          \n\n# See all private methods for Series (not intended for regular use)\nls(polars:::.pr$Series)\n\n [1] \"abs\"                    \"add\"                    \"alias\"                 \n [4] \"all\"                    \"any\"                    \"append_mut\"            \n [7] \"apply\"                  \"arg_max\"                \"arg_min\"               \n[10] \"ceil\"                   \"chunk_lengths\"          \"clone\"                 \n[13] \"compare\"                \"cumsum\"                 \"div\"                   \n[16] \"dtype\"                  \"floor\"                  \"from_arrow\"            \n[19] \"get_fmt\"                \"is_sorted\"              \"is_sorted_flag\"        \n[22] \"is_sorted_reverse_flag\" \"len\"                    \"max\"                   \n[25] \"mean\"                   \"median\"                 \"min\"                   \n[28] \"mul\"                    \"name\"                   \"new\"                   \n[31] \"panic\"                  \"print\"                  \"rem\"                   \n[34] \"rename_mut\"             \"rep\"                    \"series_equal\"          \n[37] \"set_sorted_mut\"         \"shape\"                  \"sleep\"                 \n[40] \"sort_mut\"               \"std\"                    \"sub\"                   \n[43] \"sum\"                    \"to_fmt_char\"            \"to_frame\"              \n[46] \"to_r\"                   \"value_counts\"           \"var\""
  },
  {
    "objectID": "data_manipulation.html#list-of-methods-to-apply-to-dataframe",
    "href": "data_manipulation.html#list-of-methods-to-apply-to-dataframe",
    "title": "2  Data manipulation",
    "section": "2.10 List of methods to apply to DataFrame",
    "text": "2.10 List of methods to apply to DataFrame\n👉 To learn more about the methods to be applied to the DataFrames, see this page.\n\n# See all exported methods for DataFrame\nls(polars:::DataFrame)\n\n [1] \"as_data_frame\"  \"clone\"          \"columns\"        \"drop\"          \n [5] \"drop_in_place\"  \"drop_nulls\"     \"dtype_strings\"  \"dtypes\"        \n [9] \"estimated_size\" \"fill_nan\"       \"fill_null\"      \"filter\"        \n[13] \"first\"          \"frame_equal\"    \"get_column\"     \"get_columns\"   \n[17] \"groupby\"        \"head\"           \"height\"         \"join\"          \n[21] \"join_asof\"      \"last\"           \"lazy\"           \"limit\"         \n[25] \"max\"            \"mean\"           \"median\"         \"min\"           \n[29] \"null_count\"     \"print\"          \"quantile\"       \"reverse\"       \n[33] \"schema\"         \"select\"         \"shape\"          \"shift\"         \n[37] \"shift_and_fill\" \"slice\"          \"sort\"           \"std\"           \n[41] \"sum\"            \"tail\"           \"to_data_frame\"  \"to_list\"       \n[45] \"to_series\"      \"to_struct\"      \"unique\"         \"unnest\"        \n[49] \"var\"            \"width\"          \"with_column\"    \"with_columns\"  \n\n# See all private methods for DataFrame (not intended for regular use)\nls(polars:::.pr$DataFrame)\n\n [1] \"by_agg\"                    \"clone_see_me_macro\"       \n [3] \"columns\"                   \"drop_in_place\"            \n [5] \"dtype_strings\"             \"dtypes\"                   \n [7] \"estimated_size\"            \"export_stream\"            \n [9] \"frame_equal\"               \"from_arrow_record_batches\"\n[11] \"get_column\"                \"get_columns\"              \n[13] \"lazy\"                      \"new\"                      \n[15] \"new_par_from_list\"         \"new_with_capacity\"        \n[17] \"null_count\"                \"print\"                    \n[19] \"schema\"                    \"select\"                   \n[21] \"select_at_idx\"             \"set_column_from_robj\"     \n[23] \"set_column_from_series\"    \"set_column_names_mut\"     \n[25] \"shape\"                     \"to_list\"                  \n[27] \"to_list_tag_structs\"       \"to_list_unwind\"           \n[29] \"to_struct\"                 \"unnest\""
  },
  {
    "objectID": "import_export.html#import-data",
    "href": "import_export.html#import-data",
    "title": "3  Import/Export",
    "section": "3.1 Import data",
    "text": "3.1 Import data\n\n3.1.1 Read a csv file or URL\nThe read_csv() method can be used to import a csv file from a file or an URL. read_csv() returns a DataFrame.\n\n3.1.1.1 From a file:\n\npolarsR base\n\n\n\npl$read_csv(\"examples/iris.csv\")\n\nshape: (150, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬───────────┐\n│ Sepal.Length ┆ Sepal.Width ┆ Petal.Length ┆ Petal.Width ┆ Species   │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---       │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ str       │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═══════════╡\n│ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa    │\n│ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa    │\n│ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa    │\n│ 4.6          ┆ 3.1         ┆ 1.5          ┆ 0.2         ┆ setosa    │\n│ …            ┆ …           ┆ …            ┆ …           ┆ …         │\n│ 6.3          ┆ 2.5         ┆ 5.0          ┆ 1.9         ┆ virginica │\n│ 6.5          ┆ 3.0         ┆ 5.2          ┆ 2.0         ┆ virginica │\n│ 6.2          ┆ 3.4         ┆ 5.4          ┆ 2.3         ┆ virginica │\n│ 5.9          ┆ 3.0         ┆ 5.1          ┆ 1.8         ┆ virginica │\n└──────────────┴─────────────┴──────────────┴─────────────┴───────────┘\n\n\n\n\n\nread.csv(\"examples/iris.csv\")\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1            5.1         3.5          1.4         0.2     setosa\n2            4.9         3.0          1.4         0.2     setosa\n3            4.7         3.2          1.3         0.2     setosa\n4            4.6         3.1          1.5         0.2     setosa\n5            5.0         3.6          1.4         0.2     setosa\n6            5.4         3.9          1.7         0.4     setosa\n7            4.6         3.4          1.4         0.3     setosa\n8            5.0         3.4          1.5         0.2     setosa\n9            4.4         2.9          1.4         0.2     setosa\n10           4.9         3.1          1.5         0.1     setosa\n11           5.4         3.7          1.5         0.2     setosa\n12           4.8         3.4          1.6         0.2     setosa\n13           4.8         3.0          1.4         0.1     setosa\n14           4.3         3.0          1.1         0.1     setosa\n15           5.8         4.0          1.2         0.2     setosa\n16           5.7         4.4          1.5         0.4     setosa\n17           5.4         3.9          1.3         0.4     setosa\n18           5.1         3.5          1.4         0.3     setosa\n19           5.7         3.8          1.7         0.3     setosa\n20           5.1         3.8          1.5         0.3     setosa\n21           5.4         3.4          1.7         0.2     setosa\n22           5.1         3.7          1.5         0.4     setosa\n23           4.6         3.6          1.0         0.2     setosa\n24           5.1         3.3          1.7         0.5     setosa\n25           4.8         3.4          1.9         0.2     setosa\n26           5.0         3.0          1.6         0.2     setosa\n27           5.0         3.4          1.6         0.4     setosa\n28           5.2         3.5          1.5         0.2     setosa\n29           5.2         3.4          1.4         0.2     setosa\n30           4.7         3.2          1.6         0.2     setosa\n31           4.8         3.1          1.6         0.2     setosa\n32           5.4         3.4          1.5         0.4     setosa\n33           5.2         4.1          1.5         0.1     setosa\n34           5.5         4.2          1.4         0.2     setosa\n35           4.9         3.1          1.5         0.2     setosa\n36           5.0         3.2          1.2         0.2     setosa\n37           5.5         3.5          1.3         0.2     setosa\n38           4.9         3.6          1.4         0.1     setosa\n39           4.4         3.0          1.3         0.2     setosa\n40           5.1         3.4          1.5         0.2     setosa\n41           5.0         3.5          1.3         0.3     setosa\n42           4.5         2.3          1.3         0.3     setosa\n43           4.4         3.2          1.3         0.2     setosa\n44           5.0         3.5          1.6         0.6     setosa\n45           5.1         3.8          1.9         0.4     setosa\n46           4.8         3.0          1.4         0.3     setosa\n47           5.1         3.8          1.6         0.2     setosa\n48           4.6         3.2          1.4         0.2     setosa\n49           5.3         3.7          1.5         0.2     setosa\n50           5.0         3.3          1.4         0.2     setosa\n51           7.0         3.2          4.7         1.4 versicolor\n52           6.4         3.2          4.5         1.5 versicolor\n53           6.9         3.1          4.9         1.5 versicolor\n54           5.5         2.3          4.0         1.3 versicolor\n55           6.5         2.8          4.6         1.5 versicolor\n56           5.7         2.8          4.5         1.3 versicolor\n57           6.3         3.3          4.7         1.6 versicolor\n58           4.9         2.4          3.3         1.0 versicolor\n59           6.6         2.9          4.6         1.3 versicolor\n60           5.2         2.7          3.9         1.4 versicolor\n61           5.0         2.0          3.5         1.0 versicolor\n62           5.9         3.0          4.2         1.5 versicolor\n63           6.0         2.2          4.0         1.0 versicolor\n64           6.1         2.9          4.7         1.4 versicolor\n65           5.6         2.9          3.6         1.3 versicolor\n66           6.7         3.1          4.4         1.4 versicolor\n67           5.6         3.0          4.5         1.5 versicolor\n68           5.8         2.7          4.1         1.0 versicolor\n69           6.2         2.2          4.5         1.5 versicolor\n70           5.6         2.5          3.9         1.1 versicolor\n71           5.9         3.2          4.8         1.8 versicolor\n72           6.1         2.8          4.0         1.3 versicolor\n73           6.3         2.5          4.9         1.5 versicolor\n74           6.1         2.8          4.7         1.2 versicolor\n75           6.4         2.9          4.3         1.3 versicolor\n76           6.6         3.0          4.4         1.4 versicolor\n77           6.8         2.8          4.8         1.4 versicolor\n78           6.7         3.0          5.0         1.7 versicolor\n79           6.0         2.9          4.5         1.5 versicolor\n80           5.7         2.6          3.5         1.0 versicolor\n81           5.5         2.4          3.8         1.1 versicolor\n82           5.5         2.4          3.7         1.0 versicolor\n83           5.8         2.7          3.9         1.2 versicolor\n84           6.0         2.7          5.1         1.6 versicolor\n85           5.4         3.0          4.5         1.5 versicolor\n86           6.0         3.4          4.5         1.6 versicolor\n87           6.7         3.1          4.7         1.5 versicolor\n88           6.3         2.3          4.4         1.3 versicolor\n89           5.6         3.0          4.1         1.3 versicolor\n90           5.5         2.5          4.0         1.3 versicolor\n91           5.5         2.6          4.4         1.2 versicolor\n92           6.1         3.0          4.6         1.4 versicolor\n93           5.8         2.6          4.0         1.2 versicolor\n94           5.0         2.3          3.3         1.0 versicolor\n95           5.6         2.7          4.2         1.3 versicolor\n96           5.7         3.0          4.2         1.2 versicolor\n97           5.7         2.9          4.2         1.3 versicolor\n98           6.2         2.9          4.3         1.3 versicolor\n99           5.1         2.5          3.0         1.1 versicolor\n100          5.7         2.8          4.1         1.3 versicolor\n101          6.3         3.3          6.0         2.5  virginica\n102          5.8         2.7          5.1         1.9  virginica\n103          7.1         3.0          5.9         2.1  virginica\n104          6.3         2.9          5.6         1.8  virginica\n105          6.5         3.0          5.8         2.2  virginica\n106          7.6         3.0          6.6         2.1  virginica\n107          4.9         2.5          4.5         1.7  virginica\n108          7.3         2.9          6.3         1.8  virginica\n109          6.7         2.5          5.8         1.8  virginica\n110          7.2         3.6          6.1         2.5  virginica\n111          6.5         3.2          5.1         2.0  virginica\n112          6.4         2.7          5.3         1.9  virginica\n113          6.8         3.0          5.5         2.1  virginica\n114          5.7         2.5          5.0         2.0  virginica\n115          5.8         2.8          5.1         2.4  virginica\n116          6.4         3.2          5.3         2.3  virginica\n117          6.5         3.0          5.5         1.8  virginica\n118          7.7         3.8          6.7         2.2  virginica\n119          7.7         2.6          6.9         2.3  virginica\n120          6.0         2.2          5.0         1.5  virginica\n121          6.9         3.2          5.7         2.3  virginica\n122          5.6         2.8          4.9         2.0  virginica\n123          7.7         2.8          6.7         2.0  virginica\n124          6.3         2.7          4.9         1.8  virginica\n125          6.7         3.3          5.7         2.1  virginica\n126          7.2         3.2          6.0         1.8  virginica\n127          6.2         2.8          4.8         1.8  virginica\n128          6.1         3.0          4.9         1.8  virginica\n129          6.4         2.8          5.6         2.1  virginica\n130          7.2         3.0          5.8         1.6  virginica\n131          7.4         2.8          6.1         1.9  virginica\n132          7.9         3.8          6.4         2.0  virginica\n133          6.4         2.8          5.6         2.2  virginica\n134          6.3         2.8          5.1         1.5  virginica\n135          6.1         2.6          5.6         1.4  virginica\n136          7.7         3.0          6.1         2.3  virginica\n137          6.3         3.4          5.6         2.4  virginica\n138          6.4         3.1          5.5         1.8  virginica\n139          6.0         3.0          4.8         1.8  virginica\n140          6.9         3.1          5.4         2.1  virginica\n141          6.7         3.1          5.6         2.4  virginica\n142          6.9         3.1          5.1         2.3  virginica\n143          5.8         2.7          5.1         1.9  virginica\n144          6.8         3.2          5.9         2.3  virginica\n145          6.7         3.3          5.7         2.5  virginica\n146          6.7         3.0          5.2         2.3  virginica\n147          6.3         2.5          5.0         1.9  virginica\n148          6.5         3.0          5.2         2.0  virginica\n149          6.2         3.4          5.4         2.3  virginica\n150          5.9         3.0          5.1         1.8  virginica\n\n\n\n\n\n\n\n3.1.1.2 From multiple files\nFirst, let’s create a dozen csv files\n\ndir.create(\"Datasets\")\nmydf &lt;- data.frame(\n  col1 = 1:3,\n  col2 = c(\"a\", \"b\", \"c\")\n)\nfor (i in 1:10) {\n  write.csv(mydf, file = paste0(\"Datasets/example_data_\",i,\".csv\"))\n}\n\n\n\n\n\n\n\nImportant\n\n\n\nMay 2023: Reading those multiple files into a single DataFrame is not yet implemented in R. See here for an example in Python.\n\n\n\n\n3.1.1.3 From an URL\nThe read_csv() method also works with an URL:\n\npl$read_csv(\"https://j.mp/iriscsv\")\n\ntmp file placed in \n /tmp/Rtmpq9wFUX/https...j.mp.iriscsv\n\n\nshape: (150, 5)\n┌──────────────┬─────────────┬──────────────┬─────────────┬───────────┐\n│ sepal_length ┆ sepal_width ┆ petal_length ┆ petal_width ┆ species   │\n│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---       │\n│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ str       │\n╞══════════════╪═════════════╪══════════════╪═════════════╪═══════════╡\n│ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa    │\n│ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa    │\n│ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa    │\n│ 4.6          ┆ 3.1         ┆ 1.5          ┆ 0.2         ┆ setosa    │\n│ …            ┆ …           ┆ …            ┆ …           ┆ …         │\n│ 6.3          ┆ 2.5         ┆ 5.0          ┆ 1.9         ┆ virginica │\n│ 6.5          ┆ 3.0         ┆ 5.2          ┆ 2.0         ┆ virginica │\n│ 6.2          ┆ 3.4         ┆ 5.4          ┆ 2.3         ┆ virginica │\n│ 5.9          ┆ 3.0         ┆ 5.1          ┆ 1.8         ┆ virginica │\n└──────────────┴─────────────┴──────────────┴─────────────┴───────────┘\n\n\nIf you want to use this method in lazy mode, it accepts a lazy boolean argument (FALSE by default but in this case, we prefer to use the lazy_csv_reader() method below.\n\npl$read_csv(\"examples/iris.csv\", lazy = TRUE)\n\n[1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\"\n\n  CSV SCAN examples/iris.csv\n  PROJECT */5 COLUMNS\n\n\n👉 For a complete list of arguments to use with the read_csv() method, see this page.\n\n\n\n3.1.2 Scan a csv file\nThe lazy_csv_reader() method can be used to lazily read a csv file from a file.\nlazy_csv_reader() returns a LazyFrame.\n\nThis allows the query optimizer to push down predicates and projections to the scan level, thereby potentially reducing memory overhead.\n\n\npl$lazy_csv_reader(\"examples/iris.csv\")$ # lazy, don't do a thing\n  select(\n    pl$col(c(\"Petal.Length\",\"Petal.Width\")) # select only 2 columns\n  )$\n  filter(\n    pl$col(\"Petal.Length\") &gt; 4 # the filter is pushed down the scan, so less data is read into memory\n    )$collect() # &lt;- don't forget collect() here!\n\nshape: (84, 2)\n┌──────────────┬─────────────┐\n│ Petal.Length ┆ Petal.Width │\n│ ---          ┆ ---         │\n│ f64          ┆ f64         │\n╞══════════════╪═════════════╡\n│ 4.7          ┆ 1.4         │\n│ 4.5          ┆ 1.5         │\n│ 4.9          ┆ 1.5         │\n│ 4.6          ┆ 1.5         │\n│ …            ┆ …           │\n│ 5.0          ┆ 1.9         │\n│ 5.2          ┆ 2.0         │\n│ 5.4          ┆ 2.3         │\n│ 5.1          ┆ 1.8         │\n└──────────────┴─────────────┘\n\n\n👉 For a complete list of arguments to use with the lazy_csv_reader() method, see this page.\n\n\n\n\n\n\nImportant\n\n\n\nMay 2023: arguments available in Python eol_char and with_column_names not yet supporting in R\n\n\n\n\n3.1.3 Scan a parquet file\nThe scan_parquet() method can be used to lazily read a parquet file from a file.\nScanning delays the actual parsing of the file and scan_parquet() returns a LazyFrame.\n\nscan_parquet(\"examples/iris.parquet\")\n\n[1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\"\n\n  PARQUET SCAN examples/iris.parquet\n  PROJECT */5 COLUMNS\n\n\n👉 For a complete list of arguments to use with the scan_parquet() method, see this page.\nAt the end of the query, don’t forget to use the collect() method to inform Polars that you want to execute it.\n\n\n\n\n\n\nCaution\n\n\n\nMay 2023 : Export methods have not yet been implemented in R. This methods start with write_ (write_parquet(), write_parquet(), write_json(), write_ndjson()…)"
  },
  {
    "objectID": "lazy_execution.html#introduction-to-lazy-mode",
    "href": "lazy_execution.html#introduction-to-lazy-mode",
    "title": "4  Lazy execution",
    "section": "4.1 Introduction to lazy mode",
    "text": "4.1 Introduction to lazy mode\nPolars supports two modes of operation: lazy and eager.\nLet’s start this chapter by citing the official documentation:\n\nIn the eager API the query is executed immediately while in the lazy API the query is only evaluated once it is ‘needed’. Deferring the execution to the last minute can have significant performance advantages that is why the Lazy API is preferred in most cases. Delaying execution until the last possible moment allows Polars to apply automatic optimization to every query.\n\nAs you can see, with lazy mode, you give the engine the chance to analyse what you want to do in order to propose optimal execution (for both reading and transforming datasets). Lazy evaluation is a fairly common method of improving processing speed and is used by Spark, among others.\nSo far in this book, we have only used the eager mode but fortunately all the syntax we’ve seen applies to lazy mode too. Whatever mode is used, queries will be executed transparently for users.\n\n4.1.1 Creation of a LazyFrame with lazy()\nTo convert a DataFrame to a LazyFrame we can use the lazy() contructor.\n\npl$DataFrame(iris)$lazy()\n\n[1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\"\nDF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\"\n\n\nWe are no longer working on a DataFrame but on a LazyFrame.\n\n\n4.1.2 First query passed on LazyFrame\nLet’s look at what happens when we request this LazyFrame:\n\nmyquery &lt;- pl$DataFrame(iris)$lazy()$filter(\n  pl$col(\"Species\") == \"setosa\"\n)$select(\n  pl$col(c(\"Species\", \"Petal.Length\"))\n)\nmyquery\n\n[1] \"polars LazyFrame naive plan: (run ldf$describe_optimized_plan() to see the optimized plan)\"\n SELECT [col(\"Species\"), col(\"Petal.Length\")] FROM\n  FILTER [(col(\"Species\")) == (Utf8(setosa))] FROM\n  DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT */5 COLUMNS; SELECTION: \"None\"\n\n\nThis way, we can display the naive plan but as indicated in the console, we can use the describe_optimized_plan() method to see the optimized plan.\n\nmyquery$describe_optimized_plan()\n\nFAST_PROJECT: [Species, Petal.Length]\n  DF [\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"]; PROJECT 2/5 COLUMNS; SELECTION: \"[(col(\\\"Species\\\")) == (Utf8(setosa))]\"\n\n\nThis example shows a simple but surprisingly effective element of query optimisation: projection. Changing the order in which our subset operations occur - in this case, the subset on columns first - reduces the memory overhead of the global query.\n\n\n4.1.3 Execute the plan\nTo actually execute the plan, we just need to invoke the collect() method.\n\nmyquery$collect()\n\nshape: (50, 2)\n┌─────────┬──────────────┐\n│ Species ┆ Petal.Length │\n│ ---     ┆ ---          │\n│ cat     ┆ f64          │\n╞═════════╪══════════════╡\n│ setosa  ┆ 1.4          │\n│ setosa  ┆ 1.4          │\n│ setosa  ┆ 1.3          │\n│ setosa  ┆ 1.5          │\n│ …       ┆ …            │\n│ setosa  ┆ 1.6          │\n│ setosa  ┆ 1.4          │\n│ setosa  ┆ 1.5          │\n│ setosa  ┆ 1.4          │\n└─────────┴──────────────┘"
  },
  {
    "objectID": "lazy_execution.html#lazy-vs-eager-mode-comparison",
    "href": "lazy_execution.html#lazy-vs-eager-mode-comparison",
    "title": "4  Lazy execution",
    "section": "4.2 Lazy vs eager mode comparison",
    "text": "4.2 Lazy vs eager mode comparison\nIn this first example we use the eager API:\n\ndf &lt;- pl$read_csv(\"examples/iris.csv\")\ndf_small = df$filter(pl$col(\"Petal.Length\") &gt; 5)\ndf_agg = df_small$groupby(\"Species\")$agg(pl$col(\"Petal.Width\")$median())\ndf_agg\n\nshape: (2, 2)\n┌────────────┬─────────────┐\n│ Species    ┆ Petal.Width │\n│ ---        ┆ ---         │\n│ str        ┆ f64         │\n╞════════════╪═════════════╡\n│ virginica  ┆ 2.1         │\n│ versicolor ┆ 1.6         │\n└────────────┴─────────────┘\n\n\nThis example:\n\nRead the iris dataset.\nFilter the dataset based on Petal.Length\nCalculate the median of the Petal.Width per Species\n\nEvery step is executed immediately returning the intermediate results. This can be very wastefull as we might do work or load extra data that is not being used.\nIf we instead used the lazy API and waited on execution untill all the steps are defined then the query planner could perform various optimizations. In this case:\n\nPredicate pushdown: Apply filters as early as possible while reading the dataset, thus only reading rows with sepal length greater than 5.\nProjection pushdown: Select only the columns that are needed while reading the dataset, thus removing the need to load additional columns\n\n\n\n\n\n\n\nTip\n\n\n\nTo consult the list of optimisations made by Polars on queries in lazy mode, see this page..\n\n\nHere is the equivalent code using the lazy API. At the end of the query, don’t forget to use the collect() method to inform Polars that you want to execute it.\n\npl$read_csv(\"examples/iris.csv\", lazy = TRUE)$\n  filter(\n    pl$col(\"Petal.Length\") &gt; 5)$\n  groupby(\"Species\")$\n  agg(pl$col(\"Petal.Width\")$median())$\n  collect() # &lt;- don't forget collect() here!\n\nshape: (2, 2)\n┌────────────┬─────────────┐\n│ Species    ┆ Petal.Width │\n│ ---        ┆ ---         │\n│ str        ┆ f64         │\n╞════════════╪═════════════╡\n│ versicolor ┆ 1.6         │\n│ virginica  ┆ 2.1         │\n└────────────┴─────────────┘\n\n\n\n\n\n\n\n\nImportant\n\n\n\nUse lazy execution will signficantly lower the load on memory & CPU thus allowing you to fit bigger datasets in memory and process faster.\n\n\nThe next part will demonstrate this time saving. 👇"
  },
  {
    "objectID": "lazy_execution.html#lazy-vs-eager-mode-fight",
    "href": "lazy_execution.html#lazy-vs-eager-mode-fight",
    "title": "4  Lazy execution",
    "section": "4.3 Lazy vs eager mode : fight! ⚔️",
    "text": "4.3 Lazy vs eager mode : fight! ⚔️\nFor this fight, we’re going to use a fake dataset with 1 000 000 rows and 25 columns created with the {fakir} package. The code for creating this dataset is available at the beginning of this document.\nThis fight will take place over 3 rounds :\n\nWith an eager query versus a lazy query from a DataFrame\nWith an eager query versus a lazy query from a csv file\nWith an eager query versus a lazy query from a parquet file\n\n\n4.3.1 From a DataFrame\nFor this first round and as seen above, let’s start with a simple query from a DataFrame:\n\ntic()\n#| label: fight-eager_dataframe\npl$DataFrame(fake_data)$select(\n    pl$col(c(\"region\",\"departement\",\"priority\")) \n  )$\n  filter(\n    pl$col(\"region\") == \"Aquitaine\")\n\nshape: (4_329, 3)\n┌───────────┬─────────────┬───────────┐\n│ region    ┆ departement ┆ priority  │\n│ ---       ┆ ---         ┆ ---       │\n│ str       ┆ str         ┆ cat       │\n╞═══════════╪═════════════╪═══════════╡\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ …         ┆ …           ┆ …         │\n│ Aquitaine ┆ Gironde     ┆ Silver    │\n│ Aquitaine ┆ Gironde     ┆ Silver    │\n│ Aquitaine ┆ Landes      ┆ Silver    │\n│ Aquitaine ┆ null        ┆ Silver    │\n└───────────┴─────────────┴───────────┘\n\ntoc()\n\n0.084 sec elapsed\n\n\nAs seen above, we’re going to use the lazy() method to convert a DataFrame to a LazyFrame:\n\ntic()\n#| label: fight-lazy_lazyframe\npl$DataFrame(fake_data)$lazy()$\n  select(\n    pl$col(c(\"region\",\"departement\",\"priority\")) \n  )$\n  filter(\n    pl$col(\"region\") == \"Aquitaine\")$\n  collect() # don't forget collect() here!\n\nshape: (4_329, 3)\n┌───────────┬─────────────┬───────────┐\n│ region    ┆ departement ┆ priority  │\n│ ---       ┆ ---         ┆ ---       │\n│ str       ┆ str         ┆ cat       │\n╞═══════════╪═════════════╪═══════════╡\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ Aquitaine ┆ Landes      ┆ Platinium │\n│ …         ┆ …           ┆ …         │\n│ Aquitaine ┆ Gironde     ┆ Silver    │\n│ Aquitaine ┆ Gironde     ┆ Silver    │\n│ Aquitaine ┆ Landes      ┆ Silver    │\n│ Aquitaine ┆ null        ┆ Silver    │\n└───────────┴─────────────┴───────────┘\n\ntoc()\n\n0.081 sec elapsed\n\n\n\n\n4.3.2 From a csv file\nNow, the eager mode is represented here by the read_csv() method…\n\ntic()\n#| label: fight-eager_read_csv\npl$read_csv(\"Datasets/fakir_file.csv\", infer_schema_length=0)$ \n  select(\n    pl$col(c(\"region\",\"departement\",\"priority\",\"age\")))$\n  with_columns(\n    pl$col(\"age\")$cast(pl$Int32,strict = FALSE))$\n  filter(\n    pl$col(\"region\") == \"Bretagne\")$\n  groupby(\"departement\",\"priority\")$\n  agg(pl$col(\"age\")$mean())\n\nshape: (3, 3)\n┌─────────────┬──────────┬──────┐\n│ departement ┆ priority ┆ age  │\n│ ---         ┆ ---      ┆ ---  │\n│ str         ┆ str      ┆ f64  │\n╞═════════════╪══════════╪══════╡\n│ Morbihan    ┆ Gold     ┆ 61.0 │\n│ Finistère   ┆ Gold     ┆ null │\n│ Finistère   ┆ Bronze   ┆ 31.0 │\n└─────────────┴──────────┴──────┘\n\ntoc()\n\n0.096 sec elapsed\n\n\n… while the lazy method is represented by the lazy_csv_reader:\n\ntic()\npl$lazy_csv_reader(\"Datasets/fakir_file.csv\", infer_schema_length=0)$\n  select(\n    pl$col(c(\"region\",\"departement\",\"priority\",\"age\")))$\n  with_columns(\n    pl$col(\"age\")$cast(pl$Int32,strict = FALSE))$\n  filter(\n    pl$col(\"region\") == \"Bretagne\")$\n  groupby(\"departement\",\"priority\")$\n  agg(pl$col(\"age\")$mean())$\n  collect()\n\nshape: (3, 3)\n┌─────────────┬──────────┬──────┐\n│ departement ┆ priority ┆ age  │\n│ ---         ┆ ---      ┆ ---  │\n│ str         ┆ str      ┆ f64  │\n╞═════════════╪══════════╪══════╡\n│ Finistère   ┆ Bronze   ┆ 31.0 │\n│ Finistère   ┆ Gold     ┆ null │\n│ Morbihan    ┆ Gold     ┆ 61.0 │\n└─────────────┴──────────┴──────┘\n\ntoc()\n\n0.036 sec elapsed\n\n\nWe can clearly see that we save a lot of time when executing the lazy version of the code!\n\n\n4.3.3 From a parquet file\nThe read_parquet() method has not been implemented in the R Polars package, but for this fight we will use arrow::read_parquet() and {dplyr} syntax, which will compete with polars::scan_parquet().\n\ntic()\neager_result &lt;- arrow::read_parquet(\"Datasets/fakir_file.parquet\") %&gt;% \n  filter(region == \"Bretagne\") %&gt;% \n  group_by(departement,priority) %&gt;% \n  summarise(mymean=mean(age)) %&gt;% \n  arrange(departement)\ntoc()\n\n0.197 sec elapsed\n\n\n\ntic()\nlazy_result &lt;- scan_parquet(\"Datasets/fakir_file.parquet\")$\n  filter( \n    pl$col(\"region\") == \"Bretagne\")$\n  groupby(c(\"departement\",\"priority\"))$\n  agg(\n    pl$col(c(\"age\"))$mean()\n)$collect()\ntoc()\n\n0.029 sec elapsed\n\n\nAnd it’s another victory for the lazy execution!"
  }
]